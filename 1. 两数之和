给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

示例:

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/two-sum
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

/*------------------------------------------------------------------*/
我的答案是：

用哈希表求解，将求解分解为一个动作的循环，此动作即为在哈希表中寻找正确解，不然存储当前“非正确解”。
第一遍刷题，才学到C++可以用map这类关联容器实现。很简单，因此不写详解啦。
/*-----------------------------------2020/4/15更新-------------------------------*/
与 map 的区别
STL中，map 对应的数据结构是 红黑树。红黑树是一种近似于平衡的二叉查找树，里面的数据是有序的。
在红黑树上做查找操作的时间复杂度为 O(logN)。
而 unordered_map 对应 哈希表，哈希表的特点就是查找效率高，时间复杂度为常数级别 O(1)， 
而额外空间复杂度则要高出许多。所以对于需要高效率查询的情况，使用 unordered_map 容器。
而如果对内存大小比较敏感或者数据存储要求有序的话，则可以用 map 容器。

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        map<int, int> idx;
        for(int i=0; i<n; ++i){
            if(idx.find(target-nums[i])!=idx.end()){
                return {idx[target-nums[i]], i};
            }
            else
                idx[nums[i]] = i;
        }
        return {};
    }
};

